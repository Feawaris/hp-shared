import{c as V,m as W,a as U,b as q,u as z,s as K,i as Q,d as Y,g as O,p as R,e as Z,f as I,h as P,j as B}from"./clone-bf7ZZHym.js";import{c as tt}from"./chunk-QOU2KDNW-0wiBUnW3.js";import{_ as h,l as r,d as J,p}from"./mermaid.core-DSy5ChKP.js";import{i as N,G as et}from"./graph-uLlu0vzu.js";import{m as k,l as nt}from"./layout-W1r2lxif.js";import{d as G}from"./transform-Dgtl54Jv.js";function m(n){var t={options:{directed:n.isDirected(),multigraph:n.isMultigraph(),compound:n.isCompound()},nodes:it(n),edges:rt(n)};return N(n.graph())||(t.value=V(n.graph())),t}function it(n){return k(n.nodes(),function(t){var e=n.node(t),s=n.parent(t),i={v:t};return N(e)||(i.value=e),N(s)||(i.parent=s),i})}function rt(n){return k(n.edges(),function(t){var e=n.edge(t),s={v:t.v,w:t.w};return N(t.name)||(s.name=t.name),N(e)||(s.value=e),s})}var l={},w={},F={},st=h(()=>{w={},F={},l={}},"clear"),S=h((n,t)=>(r.trace("In isDescendant",t," ",n," = ",w[t].includes(n)),!!w[t].includes(n)),"isDescendant"),at=h((n,t)=>(r.info("Descendants of ",t," is ",w[t]),r.info("Edge is ",n),n.v===t||n.w===t?!1:w[t]?w[t].includes(n.v)||S(n.v,t)||S(n.w,t)||w[t].includes(n.w):(r.debug("Tilt, ",t,",not in descendants"),!1)),"edgeInCluster"),_=h((n,t,e,s)=>{r.warn("Copying children of ",n,"root",s,"data",t.node(n),s);const i=t.children(n)||[];n!==s&&i.push(n),r.warn("Copying (nodes) clusterId",n,"nodes",i),i.forEach(a=>{if(t.children(a).length>0)_(a,t,e,s);else{const f=t.node(a);r.info("cp ",a," to ",s," with parent ",n),e.setNode(a,f),s!==t.parent(a)&&(r.warn("Setting parent",a,t.parent(a)),e.setParent(a,t.parent(a))),n!==s&&a!==n?(r.debug("Setting parent",a,n),e.setParent(a,n)):(r.info("In copy ",n,"root",s,"data",t.node(n),s),r.debug("Not Setting parent for node=",a,"cluster!==rootId",n!==s,"node!==clusterId",a!==n));const u=t.edges(a);r.debug("Copying Edges",u),u.forEach(d=>{r.info("Edge",d);const g=t.edge(d.v,d.w,d.name);r.info("Edge data",g,s);try{at(d,s)?(r.info("Copying as ",d.v,d.w,g,d.name),e.setEdge(d.v,d.w,g,d.name),r.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):r.info("Skipping copy of edge ",d.v,"-->",d.w," rootId: ",s," clusterId:",n)}catch(v){r.error(v)}})}r.debug("Removing node",a),t.removeNode(a)})},"copy"),j=h((n,t)=>{const e=t.children(n);let s=[...e];for(const i of e)F[i]=n,s=[...s,...j(i,t)];return s},"extractDescendants"),C=h((n,t)=>{r.trace("Searching",n);const e=t.children(n);if(r.trace("Searching children of id ",n,e),e.length<1)return r.trace("This is a valid node",n),n;for(const s of e){const i=C(s,t);if(i)return r.trace("Found replacement for",n," => ",i),i}},"findNonClusterChild"),X=h(n=>!l[n]||!l[n].externalConnections?n:l[n]?l[n].id:n,"getAnchorId"),ct=h((n,t)=>{if(!n||t>10){r.debug("Opting out, no graph ");return}else r.debug("Opting in, graph ");n.nodes().forEach(function(e){n.children(e).length>0&&(r.warn("Cluster identified",e," Replacement id in edges: ",C(e,n)),w[e]=j(e,n),l[e]={id:C(e,n),clusterData:n.node(e)})}),n.nodes().forEach(function(e){const s=n.children(e),i=n.edges();s.length>0?(r.debug("Cluster identified",e,w),i.forEach(a=>{if(a.v!==e&&a.w!==e){const f=S(a.v,e),u=S(a.w,e);f^u&&(r.warn("Edge: ",a," leaves cluster ",e),r.warn("Descendants of XXX ",e,": ",w[e]),l[e].externalConnections=!0)}})):r.debug("Not a cluster ",e,w)});for(let e of Object.keys(l)){const s=l[e].id,i=n.parent(s);i!==e&&l[i]&&!l[i].externalConnections&&(l[e].id=i)}n.edges().forEach(function(e){const s=n.edge(e);r.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),r.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let i=e.v,a=e.w;if(r.warn("Fix XXX",l,"ids:",e.v,e.w,"Translating: ",l[e.v]," --- ",l[e.w]),l[e.v]&&l[e.w]&&l[e.v]===l[e.w]){r.warn("Fixing and trixing link to self - removing XXX",e.v,e.w,e.name),r.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),i=X(e.v),a=X(e.w),n.removeEdge(e.v,e.w,e.name);const f=e.w+"---"+e.v;n.setNode(f,{domId:f,id:f,labelStyle:"",labelText:s.label,padding:0,shape:"labelRect",style:""});const u=structuredClone(s),d=structuredClone(s);u.label="",u.arrowTypeEnd="none",d.label="",u.fromCluster=e.v,d.toCluster=e.v,n.setEdge(i,f,u,e.name+"-cyclic-special"),n.setEdge(f,a,d,e.name+"-cyclic-special")}else if(l[e.v]||l[e.w]){if(r.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),i=X(e.v),a=X(e.w),n.removeEdge(e.v,e.w,e.name),i!==e.v){const f=n.parent(i);l[f].externalConnections=!0,s.fromCluster=e.v}if(a!==e.w){const f=n.parent(a);l[f].externalConnections=!0,s.toCluster=e.w}r.warn("Fix Replacing with XXX",i,a,e.name),n.setEdge(i,a,s,e.name)}}),r.warn("Adjusted Graph",m(n)),$(n,0),r.trace(l)},"adjustClustersAndEdges"),$=h((n,t)=>{if(r.warn("extractor - ",t,m(n),n.children("D")),t>10){r.error("Bailing out");return}let e=n.nodes(),s=!1;for(const i of e){const a=n.children(i);s=s||a.length>0}if(!s){r.debug("Done, no node has children",n.nodes());return}r.debug("Nodes = ",e,t);for(const i of e)if(r.debug("Extracting node",i,l,l[i]&&!l[i].externalConnections,!n.parent(i),n.node(i),n.children("D")," Depth ",t),!l[i])r.debug("Not a cluster",i,t);else if(!l[i].externalConnections&&n.children(i)&&n.children(i).length>0){r.warn("Cluster without external connections, without a parent and with children",i,t);let f=n.graph().rankdir==="TB"?"LR":"TB";l[i]&&l[i].clusterData&&l[i].clusterData.dir&&(f=l[i].clusterData.dir,r.warn("Fixing dir",l[i].clusterData.dir,f));const u=new et({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});r.warn("Old graph before copy",m(n)),_(i,n,u,i),n.setNode(i,{clusterNode:!0,id:i,clusterData:l[i].clusterData,labelText:l[i].labelText,graph:u}),r.warn("New graph after copy node: (",i,")",m(u)),r.debug("Old graph after copy",m(n))}else r.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l[i].externalConnections," no parent: ",!n.parent(i)," children ",n.children(i)&&n.children(i).length>0,n.children("D"),t),r.debug(l);e=n.nodes(),r.warn("New list of nodes",e);for(const i of e){const a=n.node(i);r.warn(" Now next level",i,a),a.clusterNode&&$(a.graph,t+1)}},"extractor"),A=h((n,t)=>{if(t.length===0)return[];let e=Object.assign(t);return t.forEach(s=>{const i=n.children(s),a=A(n,i);e=[...e,...a]}),e},"sorter"),ot=h(n=>A(n,n.children()),"sortNodesByHierarchy"),lt=h((n,t)=>{r.info("Creating subgraph rect for ",t.id,t);const e=J(),s=n.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),i=s.insert("rect",":first-child"),a=p(e.flowchart.htmlLabels),f=s.insert("g").attr("class","cluster-label"),u=t.labelType==="markdown"?tt(f,t.labelText,{style:t.labelStyle,useHtmlLabels:a},e):f.node().appendChild(P(t.labelText,t.labelStyle,void 0,!0));let d=u.getBBox();if(p(e.flowchart.htmlLabels)){const c=u.children[0],o=G(u);d=c.getBoundingClientRect(),o.attr("width",d.width),o.attr("height",d.height)}const g=0*t.padding,v=g/2,x=t.width<=d.width+g?d.width+g:t.width;t.width<=d.width+g?t.diff=(d.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,r.trace("Data ",t,JSON.stringify(t)),i.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-x/2).attr("y",t.y-t.height/2-v).attr("width",x).attr("height",t.height+g);const{subGraphTitleTopMargin:b}=O(e);a?f.attr("transform",`translate(${t.x-d.width/2}, ${t.y-t.height/2+b})`):f.attr("transform",`translate(${t.x}, ${t.y-t.height/2+b})`);const y=i.node().getBBox();return t.width=y.width,t.height=y.height,t.intersect=function(c){return B(t,c)},s},"rect"),dt=h((n,t)=>{const e=n.insert("g").attr("class","note-cluster").attr("id",t.id),s=e.insert("rect",":first-child"),i=0*t.padding,a=i/2;s.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2-a).attr("width",t.width+i).attr("height",t.height+i).attr("fill","none");const f=s.node().getBBox();return t.width=f.width,t.height=f.height,t.intersect=function(u){return B(t,u)},e},"noteGroup"),ft=h((n,t)=>{const e=J(),s=n.insert("g").attr("class",t.classes).attr("id",t.id),i=s.insert("rect",":first-child"),a=s.insert("g").attr("class","cluster-label"),f=s.append("rect"),u=a.node().appendChild(P(t.labelText,t.labelStyle,void 0,!0));let d=u.getBBox();if(p(e.flowchart.htmlLabels)){const c=u.children[0],o=G(u);d=c.getBoundingClientRect(),o.attr("width",d.width),o.attr("height",d.height)}d=u.getBBox();const g=0*t.padding,v=g/2,x=t.width<=d.width+t.padding?d.width+t.padding:t.width;t.width<=d.width+t.padding?t.diff=(d.width+t.padding*0-t.width)/2:t.diff=-t.padding/2,i.attr("class","outer").attr("x",t.x-x/2-v).attr("y",t.y-t.height/2-v).attr("width",x+g).attr("height",t.height+g),f.attr("class","inner").attr("x",t.x-x/2-v).attr("y",t.y-t.height/2-v+d.height-1).attr("width",x+g).attr("height",t.height+g-d.height-3);const{subGraphTitleTopMargin:b}=O(e);a.attr("transform",`translate(${t.x-d.width/2}, ${t.y-t.height/2-t.padding/3+(p(e.flowchart.htmlLabels)?5:3)+b})`);const y=i.node().getBBox();return t.height=y.height,t.intersect=function(c){return B(t,c)},s},"roundedWithTitle"),ut=h((n,t)=>{const e=n.insert("g").attr("class",t.classes).attr("id",t.id),s=e.insert("rect",":first-child"),i=0*t.padding,a=i/2;s.attr("class","divider").attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2).attr("width",t.width+i).attr("height",t.height+i);const f=s.node().getBBox();return t.width=f.width,t.height=f.height,t.diff=-t.padding/2,t.intersect=function(u){return B(t,u)},e},"divider"),ht={rect:lt,roundedWithTitle:ft,noteGroup:dt,divider:ut},M={},gt=h((n,t)=>{r.trace("Inserting cluster");const e=t.shape||"rect";M[t.id]=ht[e](n,t)},"insertCluster"),wt=h(()=>{M={}},"clear"),H=h(async(n,t,e,s,i,a)=>{r.info("Graph in recursive render: XXX",m(t),i);const f=t.graph().rankdir;r.trace("Dir in recursive render - dir:",f);const u=n.insert("g").attr("class","root");t.nodes()?r.info("Recursive render XXX",t.nodes()):r.info("No nodes found for",t),t.edges().length>0&&r.trace("Recursive edges",t.edge(t.edges()[0]));const d=u.insert("g").attr("class","clusters"),g=u.insert("g").attr("class","edgePaths"),v=u.insert("g").attr("class","edgeLabels"),x=u.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(c){const o=t.node(c);if(i!==void 0){const E=JSON.parse(JSON.stringify(i.clusterData));r.info("Setting data for cluster XXX (",c,") ",E,i),t.setNode(i.id,E),t.parent(c)||(r.trace("Setting parent",c,i.id),t.setParent(c,i.id,E))}if(r.info("(Insert) Node XXX"+c+": "+JSON.stringify(t.node(c))),o&&o.clusterNode){r.info("Cluster identified",c,o.width,t.node(c));const{ranksep:E,nodesep:D}=t.graph();o.graph.setGraph({...o.graph.graph(),ranksep:E,nodesep:D});const L=await H(x,o.graph,e,s,t.node(c),a),T=L.elem;z(o,T),o.diff=L.diff||0,r.info("Node bounds (abc123)",c,o,o.width,o.x,o.y),K(T,o),r.warn("Recursive render complete ",T,o)}else t.children(c).length>0?(r.info("Cluster - the non recursive path XXX",c,o.id,o,t),r.info(C(o.id,t)),l[o.id]={id:C(o.id,t),node:o}):(r.info("Node - the non recursive path",c,o.id,o),await Q(x,t.node(c),f))})),t.edges().forEach(function(c){const o=t.edge(c.v,c.w,c.name);r.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c)),r.info("Edge "+c.v+" -> "+c.w+": ",c," ",JSON.stringify(t.edge(c))),r.info("Fix",l,"ids:",c.v,c.w,"Translating: ",l[c.v],l[c.w]),Y(v,o)}),t.edges().forEach(function(c){r.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c))}),r.info("#############################################"),r.info("###                Layout                 ###"),r.info("#############################################"),r.info(t),nt(t),r.info("Graph after layout:",m(t));let b=0;const{subGraphTitleTotalMargin:y}=O(a);return ot(t).forEach(function(c){const o=t.node(c);r.info("Position "+c+": "+JSON.stringify(t.node(c))),r.info("Position "+c+": ("+o.x,","+o.y,") width: ",o.width," height: ",o.height),o&&o.clusterNode?(o.y+=y,R(o)):t.children(c).length>0?(o.height+=y,gt(d,o),l[o.id].node=o):(o.y+=y/2,R(o))}),t.edges().forEach(function(c){const o=t.edge(c);r.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(o),o),o.points.forEach(D=>D.y+=y/2);const E=Z(g,c,o,l,e,t,s);I(o,E)}),t.nodes().forEach(function(c){const o=t.node(c);r.info(c,o.type,o.diff),o.type==="group"&&(b=o.diff)}),{elem:u,diff:b}},"recursiveRender"),Nt=h(async(n,t,e,s,i)=>{W(n,e,s,i),U(),q(),wt(),st(),r.warn("Graph at first:",JSON.stringify(m(t))),ct(t),r.warn("Graph after:",JSON.stringify(m(t)));const a=J();await H(n,t,s,i,void 0,a)},"render");export{Nt as r};
